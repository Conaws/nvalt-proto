<?xml version="1.0"?>
<!-- OPML generated by Emacs 24.5.1 (Org mode 8.2.10) on Mon, 14 Mar 2016 18:04:46 GMT -->
<opml version="2.0">
  <head>
    <title>1</title>
    <ownerName>Conor White-Sullivan</ownerName>
    <ownerEmail>conor@Conors-MacBook-Pro.local</ownerEmail>
    <dateModified>Mon, 14 Mar 2016 00:26:23 GMT</dateModified>
    <dateCreated>Mon, 14 Mar 2016 18:04:46 GMT</dateCreated>
    <generator>https://github.com/edavis/org-opml</generator>
    <docs>http://dev.opml.org/spec2.html</docs>
  </head>
  <body>
    <outline text="&quot;** zipmap at defining myself on March 14, 2016 at 5:00 (defn vec-to-map\&quot;Return a function which accepts a parameter that is destructured according to the names listed.... then create a map where the values are all the names, and... turns out this was just zipmap \&quot;([v] (into {}))([v &amp; names] (for [n names]:let i (range 100000)]{n (nth v i)})))(defn zip-map[k v](into{} (map vec (partition 2 (interleave k v)))))://stackoverflow.com/questions/25548598/what-does-clojures-zip-map-doexample of documentation of usage:(zip-map [:a :b :c] [1 2 3]) ;=&gt; {:a 1, :b 2, :c 3} from the inside out:(interleave [:a :b :c] [1 2 3]) ;=&gt; (:a 1 :b 2 :c 3)(partition 2 '(:a 1 :b 2 :c 3)) ;=&gt; ((:a 1) (:b 2) (:c 3))(mapvec '((:a 1) (:b 2) (:c 3))) ;=&gt; ([:a 1] [:b 2] [:c 3])(into {} '([:a 1] [:b 2] [:c 3])) ;=&gt; {:a 1, :b 2, :c 3}&quot;" structure="paragraph"/>
    <outline text="zipmap" structure="headline">
      <outline text=" Attempt at defining myself on March 14, 2016 at 5:00 (defn vec-to-map &quot;Return a function which accepts a parameter that is destructured according to the names listed.... then create a map where the values are all the names, and... turns out this was just zipmap &quot; ([v] (into {})) ([v &amp; names] (for [n names]" structure="paragraph"/>
      <outline text=" :let i (range 100000)] {n (nth v i)})))" structure="paragraph"/>
      <outline text="(defn zip-map [k v] (into{} (map vec (partition 2 (interleave k v)))))" structure="paragraph"/>
      <outline text="http://stackoverflow.com/questions/25548598/what-does-clojures-zip-map-do" structure="paragraph"/>
      <outline text="Excellent example of documentation" structure="paragraph"/>
      <outline text="Example of usage: (zip-map [:a :b :c] [1 2 3]) ;=&gt; {:a 1, :b 2, :c 3} And from the inside out:" structure="paragraph"/>
      <outline text="(interleave [:a :b :c] [1 2 3]) ;=&gt; (:a 1 :b 2 :c 3) (partition 2 '(:a 1 :b 2 :c 3)) ;=&gt; ((:a 1) (:b 2) (:c 3)) (map vec '((:a 1) (:b 2) (:c 3))) ;=&gt; ([:a 1] [:b 2] [:c 3]) (into {} '([:a 1] [:b 2] [:c 3])) ;=&gt; {:a 1, :b 2, :c 3}" structure="paragraph"/>
    </outline>
    <outline text="Associate new information to global state" structure="headline">
      <outline text="Associate new information to global state -- Datascript" structure="paragraph"/>
      <outline text="Associate new information to global state -- Reagent" structure="paragraph"/>
      <outline text="Possibly using assoc-in" structure="paragraph"/>
      <outline text="** Autocomplete links" structure="paragraph"/>
      <outline text="Possible implementation 1:" structure="list"/>
      <outline text="As one is typing, an event handler updates the &lt;a href=&quot;global state atom&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="with checks to see whether the last two characters in the text area were &quot;[\[&quot; (start of a link)" structure="list"/>
      <outline text="If they were, then the text area's String value is modified according to what the user types after the &quot;[\[&quot;." structure="list"/>
      <outline text="Uses a &lt;a href=&quot;search indexer&quot;&gt;nil&lt;/a&gt; on the &lt;a href=&quot;In-memory database&quot;&gt;nil&lt;/a&gt; to find text which matches all note titles." structure="list"/>
      <outline text="The event handler stops listening after the user types &quot;]\]&quot;." structure="list"/>
      <outline text="Components" structure="paragraph"/>
      <outline text="&lt;a href=&quot;Trigger a change in global state, to initiate autocomplete links&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="&lt;a href=&quot;Generate List of possible completions from an input&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="#Questions: What are you using to hold the global state?" structure="paragraph"/>
      <outline text="What part of the global state are you updating on each keyup event" structure="paragraph"/>
      <outline text="datascript connection to update the value of the note [[]]" structure="paragraph"/>
    </outline>
    <outline text="Clojure write a string with formatting" structure="headline">
      <outline text="PS2: Sometimes it's handy to be able to see what the current directory (so &quot;.&quot;) is. You can get the absolute path in two ways: (System/getProperty &quot;user.dir&quot;)" structure="paragraph"/>
      <outline text="(-&gt; (java.io.File. &quot;.&quot;) .getAbsolutePath)" structure="paragraph"/>
      <outline text="PS: To be more explicit about the fact that you are reading and writing to a File and not something else, you could first create a File object and then coerce it into a BufferedReader or Writer: (reader (file &quot;/tmp/test.txt&quot;)) ;; or (writer (file &quot;tmp/test.txt&quot;)) The file function is also in clojure.java.io." structure="paragraph"/>
    </outline>
    <outline text="clojure.core:map" structure="headline">
      <outline text=" For each item `x` in a sequence, applies a function `f` to `x`** clojure.core:subs clojure substring calls .substring or whatever** Convert a Directory of Text files to a Mindmap #Problem: ###Given:" structure="paragraph"/>
    </outline>
    <outline text="A directory of text files" structure="headline">
      <outline text="each of which contains links to other files" structure="list">
        <outline text="? links autocomplete based on other file names in directory" structure="list"/>
      </outline>
      <outline text="###Do:" structure="paragraph"/>
      <outline text="Convert the directory into a directed graph, where each file is a node, and internal links in the file are edges." structure="list"/>
      <outline text="Display the directed graph visually" structure="list">
        <outline text="As a single nested text file" structure="list"/>
        <outline text="As a graph proper" structure="list"/>
      </outline>
      <outline text="#Paths: ## ? Directory to OrgMode to OPML" structure="paragraph"/>
      <outline text="_Parents_ Edgemap Prototype** Create a directed graph where each file is a node and the links between the nodes are edges Components:" structure="paragraph"/>
      <outline text="&lt;a href=&quot;Read all the files in a directory&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="Find all the links in a file &lt;a href=&quot;Search a string for a pattern&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="Create a graph based on links in each file" structure="list"/>
      <outline text="Comparable to Features" structure="paragraph"/>
      <outline text="Create a graph based on links in each file" structure="headline">
        <outline text="#Goal Turn a directory into a map with cycles" structure="paragraph"/>
        <outline text="Start at the root node" structure="paragraph"/>
        <outline text="Parse the text of the node For any link -- add a child to the parent Add a parent of this things Id to that parent Add a depth (check for cycles)" structure="paragraph"/>
        <outline text="Check that node to see if it has a depth, if it does then just put in a link (as in [[]]) to that node you do want things to appear at various levels of the hierarchy as long they aren't cycles. If inserting text does not create a cycle paste in the content of the node. otherwise pasted in your link" structure="paragraph"/>
        <outline text="*Heading 1 *link1" structure="paragraph"/>
        <outline text="#steps" structure="paragraph"/>
        <outline text="(def nvaltProto {&quot;Create a directed graph&quot; {:text &quot;string&quot;}}" structure="paragraph"/>
        <outline text="Find the root node" structure="paragraph"/>
        <outline text="(identify whether the graph is cyclic)" structure="paragraph"/>
        <outline text="Place that node in a file Wherever you find a link Paste in the value of that node But with a header that is of the appropriate depth If a link would cause a cycle -- don't substitute it" structure="paragraph"/>
        <outline text="File-Seq the directory Filter the ones that end in .txt map and juxt in order to get a vector of the filename and the text of the file [name text]" structure="paragraph"/>
        <outline text="for all the vectors on the right element get a set of all links in the set" structure="paragraph"/>
        <outline text="re-seq to find instances of the links use the substring to take off the brackets" structure="paragraph"/>
        <outline text="end up with 3 tuple [name text [links]]" structure="paragraph"/>
        <outline text="assume that loom would only want the links" structure="paragraph"/>
        <outline text="have {:name text} {:name nodes}" structure="paragraph"/>
        <outline text="Use Loom to create a di-graph" structure="paragraph"/>
        <outline text="Let di-graph have a variable that stores all the cycles in it (maybe a set)" structure="paragraph"/>
        <outline text=":note -- want the connections that cause the cycles" structure="paragraph"/>
        <outline text=":get the path from your starting node back to itself from loom" structure="paragraph"/>
        <outline text=":result" structure="paragraph"/>
        <outline text="Goal: Get a depth score for each of them Find all paths from your root node to all the nodes it can reach Mapping over the paths and counting them" structure="paragraph"/>
        <outline text="Filter --- getting passed b as a possible link if b have a lower depth score than a &amp;&amp; is there a cycle that contains both b &amp; a" structure="paragraph"/>
        <outline text="Next steps: Treeify" structure="paragraph"/>
        <outline text="Given the shortest paths, depths, and cycles, we can 'treeify' the cyclic graph." structure="list"/>
        <outline text="Tree -&gt; Bulleted list" structure="paragraph"/>
        <outline text="" structure="list">nil</outline>
        <outline text="Bulleted list -&gt; replace with textual content of the associated files" structure="paragraph"/>
        <outline text="Use the `files` map" structure="list"/>
        <outline text=" Give each file a &quot;depth&quot; based on when it was referenced from the root node** DataScript ** Determine possible completions of a string Take the possible set of matches As characters come in for query string -- filter the set according to your filter rule generated by the string" structure="paragraph"/>
        <outline text="#get the matches in a set Filter by has one match Sort by a rule" structure="paragraph"/>
        <outline text="#possible tools re-group re-find re-matches" structure="paragraph"/>
        <outline text="1: Use fix style searching converts string to a regex weakness won't give you results listed in order of closest match compensation/fix sorting autocompletions" structure="paragraph"/>
        <outline text="2:" structure="paragraph"/>
        <outline text="2: Leventhein distance" structure="paragraph"/>
      </outline>
      <outline text="Directory to OrgMode to OPML" structure="headline">
        <outline text="Functionality Needed" structure="paragraph"/>
        <outline text="&lt;a href=&quot;Create a directed graph where each file is a node and the links between the nodes are edges&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="&lt;a href=&quot;Write a .org file which represents the hierarchy of this graph&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="Output this .org file into OPML" structure="list"/>
        <outline text="Description: We want to look through all of the files in a nValt directory For each file, we want to grab the file name and the text of the file and store that in a data structure We'll call each pair of title and text a &quot;node&quot;" structure="paragraph"/>
        <outline text="Components Read all the Files in a Directory" structure="paragraph"/>
      </outline>
      <outline text="Display full screen" structure="headline">
        <outline text="CLJS" structure="list"/>
        <outline text="Built into JS; not available on older browsers" structure="list"/>
        <outline text="CLJ" structure="list">
          <outline text="&lt;a href=&quot;JavaFX&quot;&gt;nil&lt;/a&gt; has an option** Edgemap Prototype" structure="list"/>
        </outline>
        <outline text="What we want for the text editor Autocompletion of files Git integration" structure="paragraph"/>
        <outline text="Convert a Directory of Text files to a Mindmap" structure="paragraph"/>
      </outline>
      <outline text="Editing MVP" structure="headline">
        <outline text="Editing, for the MVP should be done only in nValt files, which would then be recompiled, so the change would happen automatically** Eliminate any cycles in the graph If there is a cycle in the graph, determine which node is globally lower, for the links from the lower to the higher, represent this as another kind of link" structure="paragraph"/>
        <outline text="When used in Write a .org file which represents the hierarchy of this graph: paste Link text rather than pasting in the text of the node. ** Features" structure="paragraph"/>
        <outline text="Note operations" structure="list"/>
        <outline text="Create a note" structure="list"/>
        <outline text="Rename a note" structure="list"/>
        <outline text="Tag a note" structure="list"/>
        <outline text="Delete a note" structure="list"/>
        <outline text="Formatting" structure="list">
          <outline text="Create a dashed list automatically &#x2014; able to be indented" structure="list"/>
          <outline text="Bold, italic, strikethrough, make text plain (with corresponding key bindings)" structure="list"/>
        </outline>
        <outline text="&lt;a href=&quot;Spelling correction&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="&lt;a href=&quot;Search notes for text&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="&lt;a href=&quot;Autocomplete links&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="Display" structure="list">
          <outline text="View/hide notes (title, date modified)" structure="list"/>
          <outline text="Horizontal vs. vertical layout" structure="list"/>
          <outline text="&lt;a href=&quot;Display full screen&quot;&gt;nil&lt;/a&gt; " structure="list"/>
          <outline text="Preview window (plain text -&gt; &quot;pretty&quot; HTML)" structure="list"/>
        </outline>
        <outline text="I/O" structure="list">
          <outline text="Import note (Load plain text)" structure="list"/>
          <outline text="Markdownify (Load URL/HTML/markdown -&gt; plain text)" structure="list"/>
          <outline text="Export note (Save as plain text)" structure="list"/>
          <outline text="Note autosave (where, as what?)" structure="list"/>
          <outline text="Save as PDF" structure="list"/>
          <outline text="Save preview HTML" structure="list"/>
        </outline>
        <outline text="Options" structure="list">
          <outline text="Enable markdown completion" structure="list"/>
        </outline>
        <outline text="Shortcuts / Key bindings" structure="list"/>
        <outline text="Encryption" structure="list"/>
        <outline text="Note linking" structure="list"/>
        <outline text="(I see improvements to be made on the features of nvALT but I will not put them here.)** fix style searching" structure="paragraph"/>
        <outline text="How is it done?" structure="paragraph"/>
        <outline text="Convert &quot;abc&quot; to regex &quot;a.*b.*c&quot;" structure="paragraph"/>
        <outline text="http://stackoverflow.com/questions/20234676/how-does-ido-flex-matching-work" structure="paragraph"/>
        <outline text=" Without looking at the code, I can guess, because the effect is the same, that it is done the same way Icicles does it: add .* after each character in your input except the last, and use string-match to match the resulting regexp against the candidates. E.g.: Input: abc. Handled as regexp: a.*b.*c. Or similar. All that does is match each of the characters in your input against the candidate, but also allow for possibly other candidate chars in between successive chars of your input. It's a kind of poor man's &quot;fuzzy&quot; matching. More info, including comparison with other fuzzy matching approaches.** General Architecture + Deployment nvALT seems to be able to be recreated with a CLJS frontend (Reagent, DataScript) within a sort of native container such that CLJS can e.g. read/write files/notes." structure="paragraph"/>
        <outline text="This is feasible via Apache Cordova, which is basically a means to deploy HTML5 apps to any platform (desktop, mobile, etc.)." structure="list">
          <outline text="There are many plugins available for Cordova, one of which is filesystem access." structure="list"/>
          <outline text="If one wishes to deploy an nvALT clone to a mobile platform, Cordova might be easier." structure="list"/>
          <outline text="Cordova seems to be by far the cleanest." structure="list"/>
        </outline>
        <outline text="This is likely possible in Node, as well, which has I/O support." structure="list"/>
        <outline text="Alternatively, one can use a local CLJ server, communicate with the UI via websockets (Sente), and use the server to perform I/O operations. Then one could use RoboVM to deploy to any mobile device. However, this is a more difficult option and involves more moving parts, if you will. ** Generate List of possible completions from an input Purposes of the feature:" structure="list"/>
        <outline text="#Challenge:" structure="paragraph"/>
        <outline text="As the user types, the available autocompletions are scoped to what they have currently typed, based on the potential file names" structure="paragraph"/>
        <outline text="1 Determine possible completions of a string" structure="paragraph"/>
        <outline text="Display in the UI" structure="list">
          <outline text="Allow the user to navigate those using arrow keys and tab/return" structure="list"/>
        </outline>
      </outline>
      <outline text="Give each file a &quot;depth&quot; based on when it was referenced from the root node" structure="headline">
        <outline text="Use the shortest path algorithm from loom** Global state atom" structure="paragraph"/>
        <outline text="Possible implementations:" structure="list"/>
        <outline text="reagent.core/ratom &lt;a href=&quot;Reagent&quot;&gt;nil&lt;/a&gt; (best)" structure="list"/>
        <outline text="freactive.core/atom" structure="list">
          <outline text="More efficient than Reagent's atoms and reactive expressions" structure="list"/>
          <outline text="Far less supported" structure="list"/>
          <outline text="Conclusion: Disadvantages outweigh benefits** In-memory database" structure="list"/>
        </outline>
        <outline text="Best implementation: &lt;a href=&quot;DataScript&quot;&gt;nil&lt;/a&gt; ** JavaFX" structure="list"/>
        <outline text="** Load note data into in-memory database Loads note data into an in-memory database." structure="paragraph"/>
        <outline text="Possible implementation:" structure="paragraph"/>
        <outline text="Given a `seq` of notes and corresponding note metadata (e.g. tags), for each note ( &lt;a href=&quot;clojure.core/map&quot;&gt;nil&lt;/a&gt; ), creates a transaction-part consisting of a &lt;a href=&quot;note entity&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="Transact the transaction to the &lt;a href=&quot;in-memory database&quot;&gt;nil&lt;/a&gt; ** Lucene" structure="list"/>
        <outline text="** March 13, 2016 Notes: if nvalt fails to autocomplete just change the directory you're pointing to and then change back" structure="paragraph"/>
        <outline text=" ** March 14, 2016 12:00 -- 3:01 Refactoring Alex's Code 3:01 -- 3:12 Break 3:12 -- 4:09 Guitar (some code)" structure="paragraph"/>
        <outline text="4:09 -- 5:00 zipmap" structure="paragraph"/>
        <outline text="5:00 -- 5:24 Clojure write a string with formatting" structure="paragraph"/>
        <outline text="5:42 Write a file from nvalt to emacs** Note Entity A note with its corresponding metadata. Represented in the in-memory database according to the defined schemas." structure="paragraph"/>
        <outline text="Possible implementation:" structure="paragraph"/>
        <outline text="Note text" structure="list">
          <outline text=":note/text, :cardinality :one, :string" structure="list"/>
        </outline>
        <outline text="Note title" structure="list">
          <outline text=":note/title, :cardinality :one, :string" structure="list"/>
        </outline>
        <outline text="Tags" structure="list">
          <outline text=":note/tags, :cardinality :many, :string** Read all the files in a directory" structure="list"/>
        </outline>
        <outline text="Clojure Core Functions" structure="paragraph"/>
        <outline text="Clojure function to grab all the files in a directory clojure.core/file-seq Performs a recursive search for all the files in a directory" structure="paragraph"/>
        <outline text="Read each file as a text string Clojure.core/slurp" structure="paragraph"/>
        <outline text="Do the same thing to each file clojure.core/map" structure="paragraph"/>
      </outline>
      <outline text="Reagent" structure="headline">
        <outline text="** schemas The schemas of the in-memory database** Search a string for a pattern re-seq" structure="paragraph"/>
        <outline text="Regular Expressions" structure="paragraph"/>
      </outline>
      <outline text="Search indexer" structure="headline">
        <outline text="Possible implementation:" structure="list"/>
        <outline text="&lt;a href=&quot;Lucene&quot;&gt;nil&lt;/a&gt; " structure="list">
          <outline text="How to use DataScript with Lucene?" structure="list">
            <outline text="Datomic uses Lucene; Datomic could do it** Search notes for text" structure="list"/>
          </outline>
        </outline>
        <outline text="Searches all notes with every keystroke" structure="list"/>
        <outline text="Possible implementation:" structure="list">
          <outline text="On application load," structure="list">
            <outline text="&lt;a href=&quot;Read all the files in a directory&quot;&gt;nil&lt;/a&gt; " structure="list"/>
            <outline text="&lt;a href=&quot;Load note data into in-memory database&quot;&gt;nil&lt;/a&gt; " structure="list"/>
            <outline text="Use a &lt;a href=&quot;search indexer&quot;&gt;nil&lt;/a&gt; to index the text to perform quick searches and autocomplete** sorting autocompletions" structure="list"/>
          </outline>
        </outline>
        <outline text="or I might want to change the style of matching** Spelling correction" structure="paragraph"/>
        <outline text="Possible implementations:" structure="list"/>
        <outline text="Built-in on Mac and iOS; I believe JavaScript uses this implementation" structure="list"/>
        <outline text="Other platforms will almost certainly need a different implementation** Start at the root node" structure="list"/>
        <outline text="#options" structure="paragraph"/>
        <outline text="Set by the user" structure="list"/>
        <outline text="Determined from loom Probably not a good answer, because the root node is among the most likely to be involved in cycles" structure="list"/>
      </outline>
      <outline text="Trigger a change in global state, to initiate autocomplete links" structure="headline">
        <outline text=" Options: Pattern matching on the string of typed input to look for [[ As one is typing Detect typing reagent onkeyup -&gt;&gt; e.-target .-value" structure="paragraph"/>
        <outline text="Update the global state atom -- to say what is currently typed swap Associate new information to global state" structure="paragraph"/>
        <outline text="Checks to see whether last two characters where start of a link subs = or get get-last count -" structure="paragraph"/>
        <outline text="Update global state atom to say you're within a link" structure="paragraph"/>
        <outline text="Options: keep an update of last character entered in global state, and trigger change when e.target .value &amp; last = [[" structure="paragraph"/>
      </outline>
      <outline text="Write a .org file which represents the hierarchy of this graph" structure="headline">
        <outline text="#Components" structure="paragraph"/>
        <outline text="Write to a file" structure="list"/>
        <outline text="Choose the correct number of stars for the indentation" structure="list"/>
        <outline text="Create links to &quot;Parents&quot; which are not the direct parent" structure="list"/>
        <outline text="&lt;a href=&quot;Eliminate any cycles in the graph&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="&lt;a href=&quot;Pasting contents of file at the location of links in Tree view&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="#Abandoned Paths" structure="paragraph"/>
        <outline text="Each time a node is changed, it is changed at every location that the node exists Reason For Abandonment: &lt;a href=&quot;Editing MVP&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="Write to a file at a specific location in the file RA: &lt;a href=&quot;Editing MVP&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      </outline>
      <outline text="Write a file from nvalt to emacs" structure="headline">
        <outline text="(defn print-page [{:keys [name text depth]}] (str (header-stars depth) &quot; &quot; name &quot; &quot; text))" structure="paragraph"/>
        <outline text="(-&gt;&gt; (read-files &quot;./nvalt-proto&quot;) last (zipmap [:name :text]) (merge {:depth 2}) print-page (#(spit &quot;./nvalt-proto/1.org&quot; % :append true)) logger)" structure="paragraph"/>
        <outline text="(-&gt; (java.io.File. &quot;.&quot;) .getAbsolutePath)** zipmap Attempt at defining myself on March 14, 2016 at 5:00 (defn vec-to-map &quot;Return a function which accepts a parameter that is destructured according to the names listed.... then create a map where the values are all the names, and... turns out this was just zipmap &quot; ([v] (into {})) ([v &amp; names] (for [n names]" structure="paragraph"/>
        <outline text=" :let i (range 100000)] {n (nth v i)})))" structure="paragraph"/>
        <outline text="(defn zip-map [k v] (into{} (map vec (partition 2 (interleave k v)))))" structure="paragraph"/>
        <outline text="http://stackoverflow.com/questions/25548598/what-does-clojures-zip-map-do" structure="paragraph"/>
        <outline text="Excellent example of documentation" structure="paragraph"/>
        <outline text="Example of usage: (zip-map [:a :b :c] [1 2 3]) ;=&gt; {:a 1, :b 2, :c 3} And from the inside out:" structure="paragraph"/>
        <outline text="(interleave [:a :b :c] [1 2 3]) ;=&gt; (:a 1 :b 2 :c 3) (partition 2 '(:a 1 :b 2 :c 3)) ;=&gt; ((:a 1) (:b 2) (:c 3)) (map vec '((:a 1) (:b 2) (:c 3))) ;=&gt; ([:a 1] [:b 2] [:c 3]) (into {} '([:a 1] [:b 2] [:c 3])) ;=&gt; {:a 1, :b 2, :c 3}" structure="paragraph"/>
      </outline>
    </outline>
    <outline text="Associate new information to global state" structure="headline">
      <outline text="Associate new information to global state -- Datascript" structure="paragraph"/>
      <outline text="Associate new information to global state -- Reagent" structure="paragraph"/>
      <outline text="Possibly using assoc-in" structure="paragraph"/>
      <outline text="Autocomplete links" structure="list"/>
      <outline text="Possible implementation 1:" structure="list">
        <outline text="As one is typing, an event handler updates the &lt;a href=&quot;global state atom&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="with checks to see whether the last two characters in the text area were &quot;[\[&quot; (start of a link)" structure="list"/>
        <outline text="If they were, then the text area's String value is modified according to what the user types after the &quot;[\[&quot;." structure="list"/>
        <outline text="Uses a &lt;a href=&quot;search indexer&quot;&gt;nil&lt;/a&gt; on the &lt;a href=&quot;In-memory database&quot;&gt;nil&lt;/a&gt; to find text which matches all note titles." structure="list"/>
        <outline text="The event handler stops listening after the user types &quot;]\]&quot;." structure="list"/>
      </outline>
      <outline text="Components" structure="paragraph"/>
      <outline text="&lt;a href=&quot;Trigger a change in global state, to initiate autocomplete links&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="&lt;a href=&quot;Generate List of possible completions from an input&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="#Questions: What are you using to hold the global state?" structure="paragraph"/>
      <outline text="What part of the global state are you updating on each keyup event" structure="paragraph"/>
      <outline text="datascript connection to update the value of the note [[]]" structure="paragraph"/>
    </outline>
    <outline text="Clojure write a string with formatting" structure="headline">
      <outline text="PS2: Sometimes it's handy to be able to see what the current directory (so &quot;.&quot;) is. You can get the absolute path in two ways: (System/getProperty &quot;user.dir&quot;)" structure="paragraph"/>
      <outline text="(-&gt; (java.io.File. &quot;.&quot;) .getAbsolutePath)" structure="paragraph"/>
      <outline text="PS: To be more explicit about the fact that you are reading and writing to a File and not something else, you could first create a File object and then coerce it into a BufferedReader or Writer: (reader (file &quot;/tmp/test.txt&quot;)) ;; or (writer (file &quot;tmp/test.txt&quot;)) The file function is also in clojure.java.io." structure="paragraph"/>
    </outline>
    <outline text="clojure.core:map" structure="headline">
      <outline text="For each item `x` in a sequence, applies a function `f` to `x`* clojure.core:subs clojure substring calls .substring or whatever* Convert a Directory of Text files to a Mindmap #Problem: ###Given:" structure="paragraph"/>
    </outline>
    <outline text="A directory of text files" structure="headline">
      <outline text="each of which contains links to other files" structure="list">
        <outline text="? links autocomplete based on other file names in directory" structure="list"/>
      </outline>
      <outline text="###Do:" structure="paragraph"/>
      <outline text="Convert the directory into a directed graph, where each file is a node, and internal links in the file are edges." structure="list"/>
      <outline text="Display the directed graph visually" structure="list">
        <outline text="As a single nested text file" structure="list"/>
        <outline text="As a graph proper" structure="list"/>
      </outline>
      <outline text="#Paths: ## ? Directory to OrgMode to OPML" structure="paragraph"/>
      <outline text="_Parents_ Edgemap Prototype* Create a directed graph where each file is a node and the links between the nodes are edges Components:" structure="paragraph"/>
      <outline text="&lt;a href=&quot;Read all the files in a directory&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="Find all the links in a file &lt;a href=&quot;Search a string for a pattern&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="Create a graph based on links in each file" structure="list"/>
      <outline text="Comparable to Features" structure="paragraph"/>
    </outline>
    <outline text="Create a graph based on links in each file" structure="headline">
      <outline text="#Goal Turn a directory into a map with cycles" structure="paragraph"/>
      <outline text="Start at the root node" structure="paragraph"/>
      <outline text="Parse the text of the node For any link -- add a child to the parent Add a parent of this things Id to that parent Add a depth (check for cycles)" structure="paragraph"/>
      <outline text="Check that node to see if it has a depth, if it does then just put in a link (as in [[]]) to that node you do want things to appear at various levels of the hierarchy as long they aren't cycles. If inserting text does not create a cycle paste in the content of the node. otherwise pasted in your link" structure="paragraph"/>
      <outline text="*Heading 1 *link1" structure="paragraph"/>
      <outline text="#steps" structure="paragraph"/>
      <outline text="(def nvaltProto {&quot;Create a directed graph&quot; {:text &quot;string&quot;}}" structure="paragraph"/>
      <outline text="Find the root node" structure="paragraph"/>
      <outline text="(identify whether the graph is cyclic)" structure="paragraph"/>
      <outline text="Place that node in a file Wherever you find a link Paste in the value of that node But with a header that is of the appropriate depth If a link would cause a cycle -- don't substitute it" structure="paragraph"/>
      <outline text="File-Seq the directory Filter the ones that end in .txt map and juxt in order to get a vector of the filename and the text of the file [name text]" structure="paragraph"/>
      <outline text="for all the vectors on the right element get a set of all links in the set" structure="paragraph"/>
      <outline text="re-seq to find instances of the links use the substring to take off the brackets" structure="paragraph"/>
      <outline text="end up with 3 tuple [name text [links]]" structure="paragraph"/>
      <outline text="assume that loom would only want the links" structure="paragraph"/>
      <outline text="have {:name text} {:name nodes}" structure="paragraph"/>
      <outline text="Use Loom to create a di-graph" structure="paragraph"/>
      <outline text="Let di-graph have a variable that stores all the cycles in it (maybe a set)" structure="paragraph"/>
      <outline text=":note -- want the connections that cause the cycles" structure="paragraph"/>
      <outline text=":get the path from your starting node back to itself from loom" structure="paragraph"/>
      <outline text=":result" structure="paragraph"/>
      <outline text="Goal: Get a depth score for each of them Find all paths from your root node to all the nodes it can reach Mapping over the paths and counting them" structure="paragraph"/>
      <outline text="Filter --- getting passed b as a possible link if b have a lower depth score than a &amp;&amp; is there a cycle that contains both b &amp; a" structure="paragraph"/>
      <outline text="Next steps: Treeify" structure="paragraph"/>
      <outline text="Given the shortest paths, depths, and cycles, we can 'treeify' the cyclic graph." structure="list"/>
      <outline text="Tree -&gt; Bulleted list" structure="paragraph"/>
      <outline text="" structure="list">nil</outline>
      <outline text="Bulleted list -&gt; replace with textual content of the associated files" structure="paragraph"/>
      <outline text="Use the `files` map" structure="list"/>
      <outline text="Give each file a &quot;depth&quot; based on when it was referenced from the root node* DataScript" structure="paragraph"/>
    </outline>
    <outline text="Determine possible completions of a string" structure="headline">
      <outline text="Take the possible set of matches As characters come in for query string -- filter the set according to your filter rule generated by the string" structure="paragraph"/>
      <outline text="#get the matches in a set Filter by has one match Sort by a rule" structure="paragraph"/>
      <outline text="#possible tools re-group re-find re-matches" structure="paragraph"/>
      <outline text="1: Use fix style searching converts string to a regex weakness won't give you results listed in order of closest match compensation/fix sorting autocompletions" structure="paragraph"/>
      <outline text="2:" structure="paragraph"/>
      <outline text="2: Leventhein distance" structure="paragraph"/>
    </outline>
    <outline text="Directory to OrgMode to OPML" structure="headline">
      <outline text="Functionality Needed" structure="paragraph"/>
      <outline text="&lt;a href=&quot;Create a directed graph where each file is a node and the links between the nodes are edges&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="&lt;a href=&quot;Write a .org file which represents the hierarchy of this graph&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="Output this .org file into OPML" structure="list"/>
      <outline text="Description: We want to look through all of the files in a nValt directory For each file, we want to grab the file name and the text of the file and store that in a data structure We'll call each pair of title and text a &quot;node&quot;" structure="paragraph"/>
      <outline text="Components Read all the Files in a Directory" structure="paragraph"/>
    </outline>
    <outline text="Display full screen" structure="headline">
      <outline text="CLJS" structure="list">
        <outline text="Built into JS; not available on older browsers" structure="list"/>
      </outline>
      <outline text="CLJ" structure="list">
        <outline text="&lt;a href=&quot;JavaFX&quot;&gt;nil&lt;/a&gt; has an option* Edgemap Prototype" structure="list"/>
      </outline>
      <outline text="Options" structure="paragraph"/>
      <outline text="What we want for the text editor Autocompletion of files Git integration" structure="paragraph"/>
      <outline text="Convert a Directory of Text files to a Mindmap" structure="paragraph"/>
    </outline>
    <outline text="Editing MVP" structure="headline">
      <outline text="Editing, for the MVP should be done only in nValt files, which would then be recompiled, so the change would happen automatically* Eliminate any cycles in the graph If there is a cycle in the graph, determine which node is globally lower, for the links from the lower to the higher, represent this as another kind of link" structure="paragraph"/>
      <outline text="When used in Write a .org file which represents the hierarchy of this graph: paste Link text rather than pasting in the text of the node. * Features" structure="paragraph"/>
      <outline text="Note operations" structure="list">
        <outline text="Create a note" structure="list"/>
        <outline text="Rename a note" structure="list"/>
        <outline text="Tag a note" structure="list"/>
        <outline text="Delete a note" structure="list"/>
      </outline>
      <outline text="Formatting" structure="list">
        <outline text="Create a dashed list automatically &#x2014; able to be indented" structure="list"/>
        <outline text="Bold, italic, strikethrough, make text plain (with corresponding key bindings)" structure="list"/>
      </outline>
      <outline text="&lt;a href=&quot;Spelling correction&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="&lt;a href=&quot;Search notes for text&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="&lt;a href=&quot;Autocomplete links&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="Display" structure="list">
        <outline text="View/hide notes (title, date modified)" structure="list"/>
        <outline text="Horizontal vs. vertical layout" structure="list"/>
        <outline text="&lt;a href=&quot;Display full screen&quot;&gt;nil&lt;/a&gt; " structure="list"/>
        <outline text="Preview window (plain text -&gt; &quot;pretty&quot; HTML)" structure="list"/>
      </outline>
      <outline text="I/O" structure="list">
        <outline text="Import note (Load plain text)" structure="list"/>
        <outline text="Markdownify (Load URL/HTML/markdown -&gt; plain text)" structure="list"/>
        <outline text="Export note (Save as plain text)" structure="list"/>
        <outline text="Note autosave (where, as what?)" structure="list"/>
        <outline text="Save as PDF" structure="list"/>
        <outline text="Save preview HTML" structure="list"/>
      </outline>
      <outline text="Options" structure="list">
        <outline text="Enable markdown completion" structure="list"/>
      </outline>
      <outline text="Shortcuts / Key bindings" structure="list"/>
      <outline text="Encryption" structure="list"/>
      <outline text="Note linking" structure="list"/>
      <outline text="(I see improvements to be made on the features of nvALT but I will not put them here.)* fix style searching" structure="paragraph"/>
      <outline text="How is it done?" structure="paragraph"/>
      <outline text="Convert &quot;abc&quot; to regex &quot;a.*b.*c&quot;" structure="paragraph"/>
      <outline text="http://stackoverflow.com/questions/20234676/how-does-ido-flex-matching-work" structure="paragraph"/>
      <outline text=" Without looking at the code, I can guess, because the effect is the same, that it is done the same way Icicles does it: add .* after each character in your input except the last, and use string-match to match the resulting regexp against the candidates. E.g.: Input: abc. Handled as regexp: a.*b.*c. Or similar. All that does is match each of the characters in your input against the candidate, but also allow for possibly other candidate chars in between successive chars of your input. It's a kind of poor man's &quot;fuzzy&quot; matching. More info, including comparison with other fuzzy matching approaches.* General Architecture + Deployment nvALT seems to be able to be recreated with a CLJS frontend (Reagent, DataScript) within a sort of native container such that CLJS can e.g. read/write files/notes." structure="paragraph"/>
      <outline text="This is feasible via Apache Cordova, which is basically a means to deploy HTML5 apps to any platform (desktop, mobile, etc.)." structure="list">
        <outline text="There are many plugins available for Cordova, one of which is filesystem access." structure="list"/>
        <outline text="If one wishes to deploy an nvALT clone to a mobile platform, Cordova might be easier." structure="list"/>
        <outline text="Cordova seems to be by far the cleanest." structure="list"/>
      </outline>
      <outline text="This is likely possible in Node, as well, which has I/O support." structure="list"/>
      <outline text="Alternatively, one can use a local CLJ server, communicate with the UI via websockets (Sente), and use the server to perform I/O operations. Then one could use RoboVM to deploy to any mobile device. However, this is a more difficult option and involves more moving parts, if you will. * Generate List of possible completions from an input" structure="list"/>
      <outline text="Purposes of the feature:" structure="paragraph"/>
      <outline text="#Challenge:" structure="paragraph"/>
      <outline text="As the user types, the available autocompletions are scoped to what they have currently typed, based on the potential file names" structure="paragraph"/>
      <outline text="1 Determine possible completions of a string" structure="paragraph"/>
      <outline text="Display in the UI" structure="list">
        <outline text="Allow the user to navigate those using arrow keys and tab/return" structure="list"/>
      </outline>
    </outline>
    <outline text="Give each file a &quot;depth&quot; based on when it was referenced from the root node" structure="headline">
      <outline text="Use the shortest path algorithm from loom* Global state atom" structure="paragraph"/>
      <outline text="Possible implementations:" structure="list">
        <outline text="reagent.core/ratom &lt;a href=&quot;Reagent&quot;&gt;nil&lt;/a&gt; (best)" structure="list"/>
        <outline text="freactive.core/atom" structure="list">
          <outline text="More efficient than Reagent's atoms and reactive expressions" structure="list"/>
          <outline text="Far less supported" structure="list"/>
          <outline text="Conclusion: Disadvantages outweigh benefits* In-memory database" structure="list"/>
        </outline>
      </outline>
      <outline text="Best implementation: &lt;a href=&quot;DataScript&quot;&gt;nil&lt;/a&gt; * JavaFX" structure="list"/>
    </outline>
    <outline text="Load note data into in-memory database" structure="headline">
      <outline text="Loads note data into an in-memory database." structure="paragraph"/>
      <outline text="Possible implementation:" structure="paragraph"/>
      <outline text="Given a `seq` of notes and corresponding note metadata (e.g. tags), for each note ( &lt;a href=&quot;clojure.core/map&quot;&gt;nil&lt;/a&gt; ), creates a transaction-part consisting of a &lt;a href=&quot;note entity&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="Transact the transaction to the &lt;a href=&quot;in-memory database&quot;&gt;nil&lt;/a&gt; * Lucene" structure="list"/>
    </outline>
    <outline text="March 13, 2016" structure="headline">
      <outline text="Notes: if nvalt fails to autocomplete just change the directory you're pointing to and then change back" structure="paragraph"/>
      <outline text="March 14, 2016" structure="list"/>
      <outline text="12:00 -- 3:01 Refactoring Alex's Code 3:01 -- 3:12 Break 3:12 -- 4:09 Guitar (some code)" structure="paragraph"/>
      <outline text="4:09 -- 5:00 zipmap" structure="paragraph"/>
      <outline text="5:00 -- 5:24 Clojure write a string with formatting" structure="paragraph"/>
      <outline text="5:42 Write a file from nvalt to emacs* Note Entity A note with its corresponding metadata. Represented in the in-memory database according to the defined schemas." structure="paragraph"/>
      <outline text="Possible implementation:" structure="paragraph"/>
      <outline text="Note text" structure="list">
        <outline text=":note/text, :cardinality :one, :string" structure="list"/>
      </outline>
      <outline text="Note title" structure="list">
        <outline text=":note/title, :cardinality :one, :string" structure="list"/>
      </outline>
      <outline text="Tags" structure="list">
        <outline text=":note/tags, :cardinality :many, :string* Read all the files in a directory" structure="list"/>
      </outline>
      <outline text="Clojure Core Functions" structure="paragraph"/>
      <outline text="Clojure function to grab all the files in a directory clojure.core/file-seq Performs a recursive search for all the files in a directory" structure="paragraph"/>
      <outline text="Read each file as a text string Clojure.core/slurp" structure="paragraph"/>
      <outline text="Do the same thing to each file clojure.core/map" structure="paragraph"/>
    </outline>
    <outline text="Reagent" structure="headline"/>
    <outline text="schemas" structure="headline">
      <outline text="The schemas of the in-memory database* Search a string for a pattern re-seq" structure="paragraph"/>
      <outline text="Regular Expressions" structure="paragraph"/>
    </outline>
    <outline text="Search indexer" structure="headline">
      <outline text="Possible implementation:" structure="list">
        <outline text="&lt;a href=&quot;Lucene&quot;&gt;nil&lt;/a&gt; " structure="list">
          <outline text="How to use DataScript with Lucene?" structure="list">
            <outline text="Datomic uses Lucene; Datomic could do it* Search notes for text" structure="list"/>
          </outline>
        </outline>
      </outline>
      <outline text="Searches all notes with every keystroke" structure="list"/>
      <outline text="Possible implementation:" structure="list">
        <outline text="On application load," structure="list">
          <outline text="&lt;a href=&quot;Read all the files in a directory&quot;&gt;nil&lt;/a&gt; " structure="list"/>
          <outline text="&lt;a href=&quot;Load note data into in-memory database&quot;&gt;nil&lt;/a&gt; " structure="list"/>
          <outline text="Use a &lt;a href=&quot;search indexer&quot;&gt;nil&lt;/a&gt; to index the text to perform quick searches and autocomplete* sorting autocompletions" structure="list"/>
        </outline>
      </outline>
      <outline text="based on other properties" structure="paragraph"/>
      <outline text="or I might want to change the style of matching* Spelling correction" structure="paragraph"/>
      <outline text="Possible implementations:" structure="list">
        <outline text="Built-in on Mac and iOS; I believe JavaScript uses this implementation" structure="list"/>
        <outline text="Other platforms will almost certainly need a different implementation* Start at the root node" structure="list"/>
      </outline>
      <outline text="#options" structure="paragraph"/>
      <outline text="Set by the user" structure="list"/>
      <outline text="Determined from loom Probably not a good answer, because the root node is among the most likely to be involved in cycles" structure="list"/>
    </outline>
    <outline text="Trigger a change in global state, to initiate autocomplete links" structure="headline">
      <outline text="Options: Pattern matching on the string of typed input to look for [[ As one is typing Detect typing reagent onkeyup -&gt;&gt; e.-target .-value" structure="paragraph"/>
      <outline text="Update the global state atom -- to say what is currently typed swap Associate new information to global state" structure="paragraph"/>
      <outline text="Checks to see whether last two characters where start of a link subs = or get get-last count -" structure="paragraph"/>
      <outline text="Update global state atom to say you're within a link" structure="paragraph"/>
      <outline text="Options: keep an update of last character entered in global state, and trigger change when e.target .value &amp; last = [[" structure="paragraph"/>
    </outline>
    <outline text="Write a .org file which represents the hierarchy of this graph" structure="headline">
      <outline text="#Components" structure="paragraph"/>
      <outline text="Write to a file" structure="list"/>
      <outline text="Choose the correct number of stars for the indentation" structure="list"/>
      <outline text="Create links to &quot;Parents&quot; which are not the direct parent" structure="list"/>
      <outline text="&lt;a href=&quot;Eliminate any cycles in the graph&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="&lt;a href=&quot;Pasting contents of file at the location of links in Tree view&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="#Abandoned Paths" structure="paragraph"/>
      <outline text="Each time a node is changed, it is changed at every location that the node exists Reason For Abandonment: &lt;a href=&quot;Editing MVP&quot;&gt;nil&lt;/a&gt; " structure="list"/>
      <outline text="Write to a file at a specific location in the file RA: &lt;a href=&quot;Editing MVP&quot;&gt;nil&lt;/a&gt; " structure="list"/>
    </outline>
    <outline text="Write a file from nvalt to emacs" structure="headline">
      <outline text="(defn print-page [{:keys [name text depth]}] (str (header-stars depth) &quot; &quot; name &quot; &quot; text))" structure="paragraph"/>
      <outline text="(-&gt;&gt; (read-files &quot;./nvalt-proto&quot;) last (zipmap [:name :text]) (merge {:depth 2}) print-page (#(spit &quot;./nvalt-proto/1.org&quot; % :append true)) logger)" structure="paragraph"/>
      <outline text="(-&gt; (java.io.File. &quot;.&quot;) .getAbsolutePath)* zipmap Attempt at defining myself on March 14, 2016 at 5:00 (defn vec-to-map &quot;Return a function which accepts a parameter that is destructured according to the names listed.... then create a map where the values are all the names, and... turns out this was just zipmap &quot; ([v] (into {})) ([v &amp; names] (for [n names]" structure="paragraph"/>
      <outline text=" :let i (range 100000)] {n (nth v i)})))" structure="paragraph"/>
      <outline text="(defn zip-map [k v] (into{} (map vec (partition 2 (interleave k v)))))" structure="paragraph"/>
      <outline text="http://stackoverflow.com/questions/25548598/what-does-clojures-zip-map-do" structure="paragraph"/>
      <outline text="Excellent example of documentation" structure="paragraph"/>
      <outline text="Example of usage: (zip-map [:a :b :c] [1 2 3]) ;=&gt; {:a 1, :b 2, :c 3} And from the inside out:" structure="paragraph"/>
      <outline text="(interleave [:a :b :c] [1 2 3]) ;=&gt; (:a 1 :b 2 :c 3) (partition 2 '(:a 1 :b 2 :c 3)) ;=&gt; ((:a 1) (:b 2) (:c 3)) (map vec '((:a 1) (:b 2) (:c 3))) ;=&gt; ([:a 1] [:b 2] [:c 3]) (into {} '([:a 1] [:b 2] [:c 3])) ;=&gt; {:a 1, :b 2, :c 3}" structure="paragraph"/>
    </outline>
    <outline text="assoc-in" structure="headline"/>
  </body>
</opml>
